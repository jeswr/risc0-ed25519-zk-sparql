// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{SPARQL_ED25519_ELF, SPARQL_ED25519_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, Journal};
use crate::load::{load_preprocessed_dir, map_preprocessed_to_verify_input};
use risc0_zkvm::Receipt;
use core::Output;
use serde::{Serialize, Deserialize};
use clap::Parser;
use clap::ValueEnum;

#[derive(ValueEnum, Clone, Debug)]
pub enum Mode {
    Prove,
    Verify,
}

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
pub struct Args {
    /// Operation mode (prove or verify)
    #[arg(short, long, value_enum, default_value = "prove")]
    pub mode: Mode,

    /// Path to the preprocessed directory
    #[arg(short, long, default_value = "./data/generated/ed25519-preprocessed/")]
    pub path: String,

    /// Path to the SPARQL query file
    #[arg(short, long, default_value = "./query.sparql")]
    pub query_file: String,

    /// Path to the output JSON file
    #[arg(short, long, default_value = "./sparql_result.json")]
    pub output_file: String,
}

#[derive(Serialize, Deserialize)]
struct Key {
    id: String,
    value: String,
}

#[derive(Serialize, Deserialize)]
struct Proof {
    #[serde(rename = "type")]
    proof_type: String,
    zkvm_id: [u32; 8],
    keys: Vec<Key>,
    inner: serde_json::Value,
    query_string: String,
    journal: String,
}

fn prove_mode(args: &Args) {
    let verify_raw = load_preprocessed_dir(&args.path);
    let mut keys: Vec<Key> = vec![];

    for i in 0..verify_raw.len() {
        let key = Key {
            id: verify_raw[i].verification_method.id.clone(),
            value: verify_raw[i].verification_method.public_key_multibase.clone(),
        };
        keys.push(key);
    }

    // Read the SPARQL query from file
    let query = std::fs::read_to_string(&args.query_file)
        .unwrap_or_else(|_| panic!("Failed to read query file: {}", args.query_file));

    let verify_inputs = map_preprocessed_to_verify_input(verify_raw);
    let env = ExecutorEnv::builder()
        .write(&verify_inputs)
        .unwrap()
        .write(&query)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    let prove_info = prover.prove(env, SPARQL_ED25519_ELF).unwrap();
    
    // extract the receipt.
    let receipt: Receipt = prove_info.receipt;

    let output = receipt.journal.decode::<Output>().unwrap();

    let mut result_object = serde_json::from_str::<serde_json::Value>(&output.result_string).unwrap();

    // Create proof struct
    let proof = Proof {
        proof_type: "Risc0ZKVM".to_string(),
        zkvm_id: SPARQL_ED25519_ID,
        keys,
        inner: serde_json::json!(&receipt.inner),
        query_string: query,
        journal: hex::encode(receipt.journal.bytes),
    };

    // Add proof to result object
    result_object["proof"] = serde_json::to_value(&proof).unwrap();

    // Write the result to the specified JSON file
    let json_file = std::fs::File::create(&args.output_file).unwrap();
    serde_json::to_writer_pretty(json_file, &result_object).unwrap();
}

fn verify_mode(args: &Args) {
    // Read the SPARQL result file
    let result_file = std::fs::File::open(&args.output_file)
        .unwrap_or_else(|_| panic!("Failed to open result file: {}", args.output_file));
    let mut result_object: serde_json::Value = serde_json::from_reader(result_file)
        .unwrap_or_else(|_| panic!("Failed to parse result file: {}", args.output_file));

    // Extract the proof information
    let proof: Proof = serde_json::from_value(result_object.get("proof")
        .unwrap_or_else(|| panic!("No proof found in result file"))
        .clone())
        .unwrap_or_else(|_| panic!("Failed to parse proof"));
    // Convert result_object to a mutable map to remove the proof
    let result_map = result_object.as_object_mut().unwrap();
    result_map.remove("proof");

    let decoded_journal = hex::decode(proof.journal.clone()).unwrap();

    let output: Output = Output {
        result_string: serde_json::to_string(result_map).unwrap(),
        pub_keys: proof.keys.iter().map(|key| key.value.clone()).collect(),
        query_string: proof.query_string,
    };

    let o2 = Journal::new(decoded_journal.clone()).decode::<Output>().unwrap();

    if o2.pub_keys.len() != output.pub_keys.len() { 
        panic!("Public keys do not match");
    }

    for i in 0..o2.pub_keys.len() {
        // Slice because the original output starts with the extra 'z'
        if o2.pub_keys[i] != output.pub_keys[i][1..].to_string() {
            panic!("Public keys do not match: {} {}", o2.pub_keys[i], output.pub_keys[i]);
        }
    }

    if o2.result_string != output.result_string {
        // Convert both strings to JSON objects for deep equality check
        let json1: serde_json::Value = serde_json::from_str(&o2.result_string)
            .unwrap_or_else(|_| panic!("Failed to parse first result string as JSON"));
        let json2: serde_json::Value = serde_json::from_str(&output.result_string)
            .unwrap_or_else(|_| panic!("Failed to parse second result string as JSON"));
        
        if json1 != json2 {
            panic!("Result JSON objects do not match");
        }
    }

    if o2.query_string != output.query_string {
        panic!("Query strings do not match");
    }

    // Create a new receipt
    let receipt = Receipt::new(
        serde_json::from_value(proof.inner).unwrap(),
        decoded_journal,
    );

    // Verify the receipt
    receipt.verify(SPARQL_ED25519_ID).unwrap();
}

pub fn run(args: &Args) {
    match args.mode {
        Mode::Prove => prove_mode(args),
        Mode::Verify => verify_mode(args),
    }
}

#[allow(dead_code)]
fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let args = Args::parse();

    let start = Instant::now();
    match args.mode {
        Mode::Prove => prove_mode(&args),
        Mode::Verify => verify_mode(&args),
    }
    let duration = start.elapsed();
    println!("Time taken: {:?}", duration);
}
