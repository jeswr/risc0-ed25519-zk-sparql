// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{SPARQL_ED25519_ELF, SPARQL_ED25519_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
mod load;
use load::{load_preprocessed_dir, map_preprocessed_to_verify_input};
use risc0_zkvm::Receipt;
use serde_json::json;
use core::Output;
use hex;
use borsh::BorshSerialize;
use bincode;


fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let verify_raw = load_preprocessed_dir("./data/generated/ed25519-preprocessed/");
    let verify_inputs = map_preprocessed_to_verify_input(verify_raw);
    let env = ExecutorEnv::builder()
        .write(&verify_inputs)
        .unwrap()
        .write(&"SELECT ?s ?p ?o WHERE { ?s ?p ?o }")
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    let start = std::time::Instant::now();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, SPARQL_ED25519_ELF).unwrap();
    
    let end = std::time::Instant::now();
    println!("Proving took {:?}", end - start);
    
    // extract the receipt.
    let receipt: Receipt = prove_info.receipt;
    // let receipt_bytes = Receipt::new(receipt.inner, receipt.journal.bytes.clone());

    let output = receipt.journal.decode::<Output>().unwrap();
    let mut result_object = serde_json::from_str::<serde_json::Value>(&output.result_string).unwrap();

    let mut buffer: Vec<u8> = Vec::new();
    receipt.inner.serialize(&mut buffer).unwrap();

    // Add a 'proof' field to the result object
    result_object["proof"] = json!({
        "type": "Risc0ZKVM",
        "zkvm_id": SPARQL_ED25519_ID,
        // "keys": verify_raw.iter().map(|key| json!({
        //     "type": "a",
        // })),
        // Hex encoding of the journal
        "inner": hex::encode(buffer),
    });

//     "proof": {
//     "type": "Ed25519Signature2020",
//     "created": "2025-05-10T14:04:18Z",
//     "verificationMethod": "did:example:dave#key-1",
//     "proofPurpose": "assertionMethod",
//     "proofValue": "zknEy6mNV2byY3hsCdPEzDiip4ZsMEwGHCzNnbkRGBEF9akB8f8ksNN5a8YFgWfAXmTU74xu1DMaKwPvPTb9nKUT"
//   }
    
    println!("Output: {:?}", result_object);

    // Write the result to a JSON file
    let json_file = std::fs::File::create("sparql_result.json").unwrap();
    serde_json::to_writer_pretty(json_file, &result_object).unwrap();
    println!("Results written to sparql_result.json");

    // TODO: Implement code for retrieving receipt journal here.

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    // let res = receipt_bytes.verify(SPARQL_ED25519_ID).expect("Receipt verification failed");
    // println!("Receipt verification result");
}
