// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{SPARQL_ED25519_ELF, SPARQL_ED25519_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
mod load;
use load::{load_preprocessed_dir, map_preprocessed_to_verify_input};
use risc0_zkvm::Receipt;
use serde_json::json;
use core::Output;
use hex;
use borsh::BorshSerialize;
use serde::{Serialize, Deserialize};
use bincode;

#[derive(Serialize, Deserialize)]
struct Key {
    id: String,
    value: String,
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let verify_raw = load_preprocessed_dir("./data/generated/ed25519-preprocessed/");
    let mut keys: Vec<Key> = vec![];

    for i in 0..verify_raw.len() {
        let key = Key {
            id: verify_raw[i].verification_method.id.clone(),
            value: verify_raw[i].verification_method.public_key_multibase.clone(),
        };
        keys.push(key);
    }

    let verify_inputs = map_preprocessed_to_verify_input(verify_raw);
    let env = ExecutorEnv::builder()
        .write(&verify_inputs)
        .unwrap()
        .write(&"SELECT ?s ?p ?o WHERE { ?s ?p ?o }")
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    let start = std::time::Instant::now();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, SPARQL_ED25519_ELF).unwrap();
    
    let end = std::time::Instant::now();
    println!("Proving took {:?}", end - start);
    
    // extract the receipt.
    let receipt: Receipt = prove_info.receipt;
    // let receipt_bytes = Receipt::new(receipt.inner, receipt.journal.bytes.clone());

    let output = receipt.journal.decode::<Output>().unwrap();
    let mut result_object = serde_json::from_str::<serde_json::Value>(&output.result_string).unwrap();

    // Add a 'proof' field to the result object
    result_object["proof"] = json!({
        "type": "Risc0ZKVM",
        "zkvm_id": SPARQL_ED25519_ID,
        "keys": serde_json::to_value(&keys).unwrap(),
        // Hex encoding of the journal
        "inner": serde_json::json!(&receipt.inner),
    });

    // Write the result to a JSON file
    let json_file = std::fs::File::create("sparql_result.json").unwrap();
    serde_json::to_writer_pretty(json_file, &result_object).unwrap();
    println!("Results written to sparql_result.json");
}
