// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{SPARQL_ED25519_ELF, SPARQL_ED25519_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
mod load;
use load::{load_preprocessed_dir, map_preprocessed_to_verify_input};
use risc0_zkvm::Receipt;
use serde_json::json;
use core::Output;
use serde::{Serialize, Deserialize};
use clap::Parser;

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the preprocessed directory
    #[arg(short, long, default_value = "./data/generated/ed25519-preprocessed/")]
    path: String,

    /// Path to the SPARQL query file
    #[arg(short, long, default_value = "./query.sparql")]
    query_file: String,

    /// Path to the output JSON file
    #[arg(short, long, default_value = "./sparql_result.json")]
    output_file: String,
}

#[derive(Serialize, Deserialize)]
struct Key {
    id: String,
    value: String,
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let args = Args::parse();
    let verify_raw = load_preprocessed_dir(&args.path);
    let mut keys: Vec<Key> = vec![];

    for i in 0..verify_raw.len() {
        let key = Key {
            id: verify_raw[i].verification_method.id.clone(),
            value: verify_raw[i].verification_method.public_key_multibase.clone(),
        };
        keys.push(key);
    }

    // Read the SPARQL query from file
    let query = std::fs::read_to_string(&args.query_file)
        .unwrap_or_else(|_| panic!("Failed to read query file: {}", args.query_file));

    let verify_inputs = map_preprocessed_to_verify_input(verify_raw);
    let env = ExecutorEnv::builder()
        .write(&verify_inputs)
        .unwrap()
        .write(&query)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    let start = std::time::Instant::now();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, SPARQL_ED25519_ELF).unwrap();
    
    let end = std::time::Instant::now();
    println!("Proving took {:?}", end - start);
    
    // extract the receipt.
    let receipt: Receipt = prove_info.receipt;
    // let receipt_bytes = Receipt::new(receipt.inner, receipt.journal.bytes.clone());

    let output = receipt.journal.decode::<Output>().unwrap();
    let mut result_object = serde_json::from_str::<serde_json::Value>(&output.result_string).unwrap();

    // Add a 'proof' field to the result object
    result_object["proof"] = json!({
        "type": "Risc0ZKVM",
        "zkvm_id": SPARQL_ED25519_ID,
        "keys": serde_json::to_value(&keys).unwrap(),
        // Hex encoding of the journal
        "inner": serde_json::json!(&receipt.inner),
    });

    // Write the result to the specified JSON file
    let json_file = std::fs::File::create(&args.output_file).unwrap();
    serde_json::to_writer_pretty(json_file, &result_object).unwrap();
    println!("Results written to {}", args.output_file);
}
